<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bioc on G. Yu</title>
    <link>http://guangchuangyu.github.io/categories/bioc/</link>
    <description>Recent content in Bioc on G. Yu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Jan 2015 03:50:23 +0800</lastBuildDate>
    <atom:link href="http://guangchuangyu.github.io/categories/bioc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ggtree in Bioconductor 3.1</title>
      <link>http://guangchuangyu.github.io/2015/01/ggtree-in-bioconductor-3.1/</link>
      <pubDate>Mon, 19 Jan 2015 03:50:23 +0800</pubDate>
      
      <guid>http://guangchuangyu.github.io/2015/01/ggtree-in-bioconductor-3.1/</guid>
      <description>&lt;p&gt;I am very glad that &lt;a href=&#34;http://guangchuangyu.github.io/2014/12/ggtree/&#34;&gt;ggtree&lt;/a&gt; is now
available via Bioconductor. This is my 6th Bioconductor package.
&lt;a href=&#34;http://guangchuangyu.github.io/2014/12/ggtree/&#34;&gt;ggtree&lt;/a&gt; now supports parsing output
files from BEAST, PAML, HYPHY, EPA and PPLACER and can annotate
phylogenetic tree directly using plot methods. Now you can use the
following
&lt;a href=&#34;http://guangchuangyu.github.io/2014/12/ggtree/&#34;&gt;command&lt;/a&gt; to
install ggtree:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;install.packages(&amp;quot;ggtree&amp;quot;,
                 repos = &amp;quot;http://www.bioconductor.org/packages/devel/bioc&amp;quot;,
                 type  = &amp;quot;source&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find out more at
&lt;a href=&#34;http://www.bioconductor.org/packages/3.1/bioc/html/ggtree.html&#34;&gt;http://www.bioconductor.org/packages/3.1/bioc/html/ggtree.html&lt;/a&gt; and
check out the vignette,
&lt;a href=&#34;http://www.bioconductor.org/packages/3.1/bioc/vignettes/ggtree/inst/doc/ggtree.html&#34;&gt;http://www.bioconductor.org/packages/3.1/bioc/vignettes/ggtree/inst/doc/ggtree.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bug of R package ChIPpeakAnno</title>
      <link>http://guangchuangyu.github.io/2014/01/bug-of-r-package-chippeakanno/</link>
      <pubDate>Tue, 14 Jan 2014 17:09:07 +0800</pubDate>
      
      <guid>http://guangchuangyu.github.io/2014/01/bug-of-r-package-chippeakanno/</guid>
      <description>&lt;p&gt;I used R package &lt;strong&gt;ChIPpeakAnno&lt;/strong&gt; for annotating peaks, and found that
it handle the DNA strand in the wrong way. Maybe the developers were
from the computer science but not biology background.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; require(ChIPpeakAnno)
&amp;gt; packageVersion(&amp;quot;ChIPpeakAnno&amp;quot;)
[1] &#39;2.10.0&#39;
&amp;gt; peak &amp;lt;- RangedData(space=&amp;quot;chr1&amp;quot;, IRanges(24736757, 24737528))
&amp;gt; data(TSS.human.GRCh37)
&amp;gt; ap &amp;lt;- annotatePeakInBatch(peak, Annotation=TSS.human.GRCh37)
&amp;gt; ap
RangedData with 1 row and 9 value columns across 1 space
                     space               ranges |        peak      strand
                               |  
1 ENSG00000001461        1 [24736757, 24737528] |           1           +
                          feature start_position end_position insideFeature
                                   
1 ENSG00000001461 ENSG00000001461       24742284     24799466      upstream
                  distancetoFeature shortestDistance fromOverlappingOrNearest
                                                
1 ENSG00000001461             -5527             4756             NearestStart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, I defined a peak ranging from chr1:24736757 to
chr1:24737528 and annotated the peak using ChIPpeakAnno package.&lt;/p&gt;

&lt;p&gt;It returns that the nearest gene is ENSG00000001461, whose gene symbol
is NIPAL3.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; require(org.Hs.eg.db)
&amp;gt; gene.ChIPpeakAnno &amp;lt;- select(org.Hs.eg.db, key=ap$feature, keytype=&amp;quot;ENSEMBL&amp;quot;, columns=c(&amp;quot;ENSEMBL&amp;quot;, &amp;quot;ENTREZID&amp;quot;, &amp;quot;SYMBOL&amp;quot;))
&amp;gt; gene.ChIPpeakAnno
          ENSEMBL ENTREZID SYMBOL
1 ENSG00000001461    57185 NIPAL3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When looking at the peak in Genome Browser, I found the nearest gene is
STPG1.
&lt;img src=&#34;https://raw.githubusercontent.com/GuangchuangYu/ygc_name/master/2014/01/Screenshot-2014-01-13-22.00.46.png&#34; alt=&#34;&#34; /&gt;
The gene symbol, STPG1, was converted to ENTREZID for future processing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; gene.nearest &amp;lt;- select(org.Hs.eg.db, key=&amp;quot;STPG1&amp;quot;, keytype=&amp;quot;SYMBOL&amp;quot;, columns=c(&amp;quot;ENSEMBL&amp;quot;, &amp;quot;ENTREZID&amp;quot;, &amp;quot;SYMBOL&amp;quot;))
&amp;gt; gene.nearest
  SYMBOL         ENSEMBL ENTREZID
1  STPG1 ENSG00000001460    90529
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can query the coordination of these two genes, and compare their
distances to the peak.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; require(TxDb.Hsapiens.UCSC.hg19.knownGene)
&amp;gt; knownGene &amp;lt;- transcriptsBy(TxDb.Hsapiens.UCSC.hg19.knownGene, by=&amp;quot;gene&amp;quot;)
&amp;gt; 
&amp;gt; gene.ChIPpeakAnno.info &amp;lt;- knownGene[[gene.ChIPpeakAnno$ENTREZID]]
&amp;gt; gene.ChIPpeakAnno.info
GRanges with 4 ranges and 2 metadata columns:
      seqnames               ranges strand |     tx_id     tx_name
                        |  
  [1]     chr1 [24742245, 24781314]      + |       618  uc010oek.2
  [2]     chr1 [24742245, 24799473]      + |       619  uc001bjh.3
  [3]     chr1 [24742245, 24799473]      + |       620  uc009vrc.3
  [4]     chr1 [24782628, 24792864]      + |       621  uc001bji.3
  ---
  seqlengths:
                    chr1                  chr2 ...        chrUn_gl000249
               249250621             243199373 ...                 38502
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After getting the information of the gene annotated by ChIPpeakAnno, I
also found that the ranges of the gene is slightly different from the
one returned by &lt;em&gt;annotatePeakInBatch&lt;/em&gt; function. This may due to the
variation of different versions and it&amp;rsquo;s not a big deal.&lt;/p&gt;

&lt;p&gt;As the gene, NIPAL3, is encoded in + strand, the nearest distance is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; min(abs(start(peak) - start(gene.ChIPpeakAnno.info)))
[1] 5488
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the gene, STPG1, is encoded in - strand, the end of the gene
coordination is actually the start position of the gene and the start of
the gene coordination is the end position. So the distance should be
calculated by the end coordination.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;&amp;gt; gene.nearest.info &amp;lt;- knownGene[[gene.nearest$ENTREZID]]
&amp;gt; gene.nearest.info
GRanges with 6 ranges and 2 metadata columns:
      seqnames               ranges strand |     tx_id     tx_name
                        |  
  [1]     chr1 [24683489, 24700300]      - |      4706  uc010oej.2
  [2]     chr1 [24683489, 24740262]      - |      4707  uc001bja.3
  [3]     chr1 [24683489, 24740262]      - |      4708  uc001bjb.3
  [4]     chr1 [24683489, 24740262]      - |      4709  uc001bjc.3
  [5]     chr1 [24683489, 24741587]      - |      4710  uc001bjd.3
  [6]     chr1 [24695211, 24718169]      - |      4711  uc001bjf.3
  ---
  seqlengths:
                    chr1                  chr2 ...        chrUn_gl000249
               249250621             243199373 ...                 38502
&amp;gt; min(abs(end(peak) - end(knownGene[[gene.nearest$ENTREZID]])))
[1] 2734
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;STPG1 is more close to the peak than NIPAL3. Those genes encoded in -
strand can&amp;rsquo;t be well-handled by &lt;strong&gt;ChIPpeakAnno&lt;/strong&gt; package.&lt;/p&gt;

&lt;p&gt;I look careful to the source code of &lt;em&gt;annotatePeakInBatch&lt;/em&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;    TSS.ordered &amp;lt;- AnnotationData
    rm(AnnotationData)
    if (!length(rownames(TSS.ordered))) {
        rownames(TSS.ordered) = formatC(1:dim(TSS.ordered)[1],
            width = nchar(dim(TSS.ordered)[1]), flag = &amp;quot;0&amp;quot;)
    }
    if (length(TSS.ordered$strand) == length(start(TSS.ordered))) {
        r2 = cbind(rownames(TSS.ordered), start(TSS.ordered),
            end(TSS.ordered), as.character(TSS.ordered$strand))
    }
    else {
        TSS.ordered$strand = rep(&amp;quot;+&amp;quot;, length(start(TSS.ordered)))
        r2 = cbind(rownames(TSS.ordered), start(TSS.ordered),
            end(TSS.ordered), rep(&amp;quot;+&amp;quot;, length(start(TSS.ordered))))
    }
    colnames(r2) = c(&amp;quot;feature_id&amp;quot;, &amp;quot;start_position&amp;quot;, &amp;quot;end_position&amp;quot;,
        &amp;quot;strand&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;AnnotationData&lt;/em&gt; object is provided by the package, or query from
biomaRt, the length(TSS.ordered\$strand) == length(start(TSS.ordered)
should be TRUE, and this code should works fine. But when the expression
return FALSE, the function should complain this, with warning message
showing in the screen or even stop running. But the author just simply
assign all the genes encoded in + strand, this is nonsense.&lt;/p&gt;

&lt;p&gt;Then for calculating the feauture location:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;    if (FeatureLocForDistance == &amp;quot;middle&amp;quot; || FeatureLocForDistance ==
        &amp;quot;m&amp;quot;) {
        FeatureLoc = unlist(lapply(1:dim(r2)[1], function(i) {
            round(mean(c(as.numeric(r2[i, 2]), as.numeric(r2[i,
                3]))))
        }))
        FeatureLocForDistance = &amp;quot;middle&amp;quot;
    }
    else if (FeatureLocForDistance == &amp;quot;start&amp;quot; || FeatureLocForDistance ==
        &amp;quot;s&amp;quot;) {
        FeatureLoc = r2[, 2]
        FeatureLocForDistance = &amp;quot;start&amp;quot;
    }
    else if (FeatureLocForDistance == &amp;quot;end&amp;quot; || FeatureLocForDistance ==
        &amp;quot;e&amp;quot;) {
        FeatureLoc = r2[, 3]
        FeatureLocForDistance = &amp;quot;end&amp;quot;
    }
    else if (FeatureLocForDistance == &amp;quot;geneEnd&amp;quot; || FeatureLocForDistance ==
        &amp;quot;g&amp;quot;) {
        FeatureLoc = unlist(lapply(1:dim(r2)[1], function(i) {
            if (as.character(r2[i, 4]) == &amp;quot;+&amp;quot; || as.character(r2[i,
                4]) == &amp;quot;1&amp;quot; || as.character(r2[i, 4]) == &amp;quot;*&amp;quot;) {
                r2[i, 3]
            }
            else {
                r2[i, 2]
            }
        }))
        FeatureLocForDistance = &amp;quot;geneEnd&amp;quot;
    }
    else {
        FeatureLoc = unlist(lapply(1:dim(r2)[1], function(i) {
            if (as.character(r2[i, 4]) == &amp;quot;+&amp;quot; || as.character(r2[i,
                4]) == &amp;quot;1&amp;quot; || as.character(r2[i, 4]) == &amp;quot;*&amp;quot;) {
                r2[i, 2]
            }
            else {
                r2[i, 3]
            }
        }))
        FeatureLocForDistance = &amp;quot;TSS&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only &amp;ldquo;geneEnd&amp;rdquo; and &amp;ldquo;TSS&amp;rdquo; types consider the strand information. For
&amp;ldquo;middle&amp;rdquo;, omits the strand information should be fine, but for &amp;ldquo;start&amp;rdquo;
and &amp;ldquo;end&amp;rdquo;, the &amp;ldquo;start&amp;rdquo; should be &amp;ldquo;end&amp;rdquo; and &amp;ldquo;end&amp;rdquo; should be &amp;ldquo;start&amp;rdquo; when
the gene is located at - strand. Again, the &lt;em&gt;annotatePeakInBatch&lt;/em&gt;
function omits the strand information of genes/features.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lang=&amp;quot;rsplus&amp;quot;&#34;&gt;        TSS.ordered$FeatureLoc = FeatureLoc
        myPeakList$PeakLoc = PeakLoc
        plusAnno = TSS.ordered[as.character(TSS.ordered$strand) %in%
            c(&amp;quot;+&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;1&amp;quot;), ]
        minusAnno = TSS.ordered[as.character(TSS.ordered$strand) %in%
            c(&amp;quot;-1&amp;quot;, &amp;quot;-&amp;quot;), ]
        r1 = do.call(rbind, lapply(seq_len(numberOfChromosome),
            function(i) {
                chr = allChr[i]
                if (chr %in% allChr.Anno) {
                  featureStart = as.numeric(TSS.ordered[chr]$FeatureLoc)
                  peakLoc = as.numeric(myPeakList[chr]$PeakLoc)
                  peakStart = as.numeric(start(myPeakList[chr]))
                  peakEnd = as.numeric(end(myPeakList[chr]))
                  name = rownames(myPeakList[chr])
                  peakRanges = IRanges(start = peakStart, end = peakEnd,
                    names = name)
                  featureID = rownames(TSS.ordered[chr])
                  featureRanges = IRanges(start = featureStart,
                    end = featureStart, names = featureID)
                  nearestFeature = featureRanges[nearest(peakRanges,
                    featureRanges)]
                  data.frame(name = name, feature_id = names(nearestFeature))
                }
            }))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For identifying the nearest feature, the author use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nearestFeature = featureRanges[nearest(peakRanges,
                    featureRanges)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;start&amp;rdquo; of the features should be used when it were encoded in +
strand and &amp;ldquo;end&amp;rdquo; when features were encoded in - strand. But the author
use &lt;em&gt;nearest&lt;/em&gt; function which use both &amp;ldquo;start&amp;rdquo; and &amp;ldquo;end&amp;rdquo; of the interval
to calculate the distance by default.&lt;/p&gt;

&lt;p&gt;Considering the &amp;ldquo;start&amp;rdquo; and &amp;ldquo;end&amp;rdquo; records may reverse when the
genes/features were encoded in - strand and the way ChIPpeakAnno
calcultes the distance is too simple by using &lt;em&gt;nearest&lt;/em&gt; function, I
can&amp;rsquo;t trust their results. It&amp;rsquo;s not hard to implement a function to
annotate peaks. Preparing the gene annotation and calculating the
distances among genes and peaks for finding the nearest gene of the
peak. That&amp;rsquo;s it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GOSemSim</title>
      <link>http://guangchuangyu.github.io/2008/08/gosemsim/</link>
      <pubDate>Mon, 11 Aug 2008 14:21:00 +0800</pubDate>
      
      <guid>http://guangchuangyu.github.io/2008/08/gosemsim/</guid>
      <description>&lt;p&gt;第一次写软件包，计算基因和GO的语义相似性。&lt;/p&gt;

&lt;p&gt;实现&lt;a href=&#34;http://bioinformatics.oxfordjournals.org/cgi/content/full/23/10/1274&#34;&gt;Wang&lt;/a&gt;的方法，基于GO的图结构。
以及四种基于信息含量的计算方法（Resnik, Jiang, Lin, Rel）。&lt;/p&gt;

&lt;p&gt;可以从Bioconductor下载到。
&lt;a href=&#34;http://bioconductor.org/packages/release/bioc/html/GOSemSim.html&#34;&gt;http://bioconductor.org/packages/release/bioc/html/GOSemSim.html&lt;/a&gt;
&lt;a href=&#34;http://bioconductor.org/packages/devel/bioc/html/GOSemSim.html&#34;&gt;http://bioconductor.org/packages/devel/bioc/html/GOSemSim.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;支持human, rat, mouse, fly, yeast, zebrafish,worm, E coli,
arabidopsis等物种。&lt;/p&gt;

&lt;p&gt;下载量统计如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bioconductor.org/packages/stats/bioc/GOSemSim.png&#34; alt=&#34;&#34; title=&#34;GOSemSim_Downloads&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
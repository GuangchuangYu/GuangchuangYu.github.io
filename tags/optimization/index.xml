<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>optimization | Guangchuang YU</title>
    <link>https://guangchuangyu.github.io/tags/optimization/</link>
      <atom:link href="https://guangchuangyu.github.io/tags/optimization/index.xml" rel="self" type="application/rss+xml" />
    <description>optimization</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2019 Guangchuang YU</copyright><lastBuildDate>Sat, 01 Jan 2011 08:52:48 +0800</lastBuildDate>
    <image>
      <url>https://guangchuangyu.github.io/img/icon-192.png</url>
      <title>optimization</title>
      <link>https://guangchuangyu.github.io/tags/optimization/</link>
    </image>
    
    <item>
      <title>Single variable optimization</title>
      <link>https://guangchuangyu.github.io/post/r/spurs/2011_single-variable-optimization/</link>
      <pubDate>Sat, 01 Jan 2011 08:52:48 +0800</pubDate>
      <guid>https://guangchuangyu.github.io/post/r/spurs/2011_single-variable-optimization/</guid>
      <description>&lt;p&gt;Optimization means to seek minima or maxima of a funtion within a given defined domain.&lt;/p&gt;

&lt;p&gt;If a function reach its maxima or minima, the derivative at that point is approaching to 0. If we apply &lt;a href=&#34;https://mp.weixin.qq.com/s/qhT_sooSINjjvWpwq2d1VA&#34; target=&#34;_blank&#34;&gt;Newton-Raphson method&lt;/a&gt; for root finding to &lt;code&gt;f&#39;&lt;/code&gt;, we can get the optimized &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f2df &amp;lt;- function(fun) {
    fun.list = as.list(fun)
    var &amp;lt;- names(fun.list[1])
    fun.exp = fun.list[[2]] 
    diff.fun = D(fun.exp, var) 
    df = list(x=0, diff.fun) 
    df = as.function(df) 
    return(df)
}

newton &amp;lt;- function(fun, x0, tol=1e-7, niter=100) { 
    df = f2df(fun) 
    for (i in 1:niter) { 
        x = x0 - fun(x0)/df(x0) 
        if (abs(fun(x)) &amp;lt; tol) 
            return(x) 
        x0 = x      
    } 
    stop(&amp;quot;exceeded allowed number of iterations&amp;quot;) 
}
    
newton_optimize &amp;lt;- function(fun, x0, tol=1e-7, niter=100) {
    df &amp;lt;- f2df(fun)
    x = newton(df, x0, tol, niter)
    ddf &amp;lt;- f2df(df)
    if (ddf(x) &amp;gt; 0) {
        cat (&amp;quot;minima:\t&amp;quot;, x, &amp;quot;\n&amp;quot;)
    } else {
        cat (&amp;quot;maxima:\t&amp;quot;, x, &amp;quot;\n&amp;quot;)
    }
    return(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Golden_section_search&#34; target=&#34;_blank&#34;&gt;golden-section method&lt;/a&gt; does not need &lt;code&gt;f&#39;&lt;/code&gt;. And it is similar to the root-bracketing technique for root finding.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gSection &amp;lt;- function(f, x1, x2, x3, tol=1e-7) {
    r &amp;lt;- 2 - (1+sqrt(5))/2 
    x4 &amp;lt;- x2 + (x3-x2)*r
    if ( abs(x3-x1) &amp;lt; tol ){
        return(x2)
    }
    if (f(x4) &amp;lt; f(x2)) {
        gSection(f, x2, x4, x3, tol)
    } else {
        gSection(f, x4, x2, x1, tol)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; f &amp;lt;- function(x) (x-1/3)^2
&amp;gt; newton_optimize(f, 0, tol=1e-7)
minima:  0.3333333 
[1] 0.3333333
&amp;gt; gSection(f, 0,0.5,1)
[1] 0.3333333
&amp;gt; optimize(f, c(0,1), tol=1e-7)
$minimum
[1] 0.3333333

$objective
[1] 0
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
